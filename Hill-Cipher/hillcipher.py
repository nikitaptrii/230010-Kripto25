# -*- coding: utf-8 -*-
"""T2_Kriptografi_Code.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kSrnJzb75dOt5fGmbUh050wFhC2CD_G4
"""

# hillcipher_findkey.py
import numpy as np
import math
from itertools import combinations

MOD = 26

# -------- helpers ----------
def text_to_numbers(text):
    return [ord(c) - ord('A') for c in text.upper() if c.isalpha()]

def numbers_to_text(nums):
    return ''.join(chr(int(n) + ord('A')) for n in nums)

def matrix_mod_inv(mat, mod):
    """
    Return inverse of integer matrix `mat` modulo `mod`.
    Supports n x n (n up to small numbers; uses cofactors).
    Raises ValueError if not invertible (gcd(det,mod) != 1).
    """
    mat = np.array(mat, dtype=int)
    n = mat.shape[0]
    if mat.shape[0] != mat.shape[1]:
        raise ValueError("matrix must be square for modular inverse")

    # determinant as integer
    det = int(round(np.linalg.det(mat)))
    det_mod = det % mod
    if math.gcd(det_mod, mod) != 1:
        raise ValueError("determinant {} not invertible mod {}".format(det_mod, mod))
    det_inv = pow(det_mod, -1, mod)  # modular inverse of determinant

    # compute matrix of cofactors (adjugate = cofactor.T)
    cof = np.zeros((n,n), dtype=int)
    for i in range(n):
        for j in range(n):
            # minor by removing row i and col j
            minor = np.delete(np.delete(mat, i, axis=0), j, axis=1)
            # determinant of minor
            minor_det = int(round(np.linalg.det(minor))) if minor.size else 1
            cof[i, j] = ((-1) ** (i + j)) * minor_det

    adj = cof.T
    inv = (det_inv * adj) % mod
    inv = inv.astype(int) % mod
    return inv

# -------- Hill functions ----------
def hill_encrypt(plaintext, key):
    n = key.shape[0]
    nums = text_to_numbers(plaintext)
    # pad with 'A' (0) if needed
    if len(nums) % n != 0:
        nums += [0] * (n - len(nums) % n)
    C = []
    for i in range(0, len(nums), n):
        block = np.array(nums[i:i+n])
        enc = (key @ block) % MOD
        C.extend(enc.tolist())
    return numbers_to_text(C)

def hill_decrypt(ciphertext, key):
    n = key.shape[0]
    nums = text_to_numbers(ciphertext)
    det = int(round(np.linalg.det(key))) % MOD
    if math.gcd(det, MOD) != 1:
        raise ValueError("Key matrix not invertible modulo 26")
    key_inv = matrix_mod_inv(key, MOD)
    P = []
    for i in range(0, len(nums), n):
        block = np.array(nums[i:i+n])
        dec = (key_inv @ block) % MOD
        P.extend(dec.tolist())
    return numbers_to_text(P)

def find_key(plaintext, ciphertext, n=2):
    """
    Attempt to find key matrix K (n x n) given plaintext and ciphertext.
    - plaintext/ciphertext must be multiple of n
    - The function will try combinations of n columns (blocks) to find
      an invertible P_sub matrix (mod 26). If found, compute K = C_sub * P_sub_inv mod 26.
    """
    p_nums = text_to_numbers(plaintext)
    c_nums = text_to_numbers(ciphertext)

    if len(p_nums) != len(c_nums):
        raise ValueError("Plaintext and ciphertext must have same length")

    if len(p_nums) % n != 0:
        raise ValueError("Length must be multiple of n")

    # build matrix with columns = consecutive blocks of size n
    # shape: (n, num_blocks)
    P = np.array(p_nums).reshape(-1, n).T
    C = np.array(c_nums).reshape(-1, n).T
    num_blocks = P.shape[1]

    if num_blocks < n:
        raise ValueError("Not enough blocks to form an n x n matrix (need at least n blocks)")

    # Try all combinations of n column indices
    for cols in combinations(range(num_blocks), n):
        P_sub = P[:, cols]
        C_sub = C[:, cols]
        try:
            P_inv_mod = matrix_mod_inv(P_sub, MOD)
        except ValueError:
            continue  # not invertible, try next combination

        # Compute K = C_sub @ P_inv_mod (mod 26)
        K = (C_sub @ P_inv_mod) % MOD
        K = K.astype(int) % MOD
        return K

    raise ValueError("No invertible submatrix found â€” cannot determine key from given pairs")

# =======================
# Program interaktif
# =======================
if __name__ == "__main__":
    print("=== Program Hill Cipher (improved find_key) ===")
    print("1. Enkripsi")
    print("2. Dekripsi")
    print("3. Cari Kunci dari pasangan (plaintext, ciphertext)")
    pilih = input("Pilih menu (1/2/3): ").strip()

    if pilih == "1":
        plaintext = input("Masukkan plaintext (A-Z): ").strip()
        n = int(input("Ordo matriks kunci (misal 2 untuk 2x2): ").strip())
        print("Masukkan elemen matriks kunci (baris per baris; spasi pemisah):")
        key_rows = []
        for i in range(n):
            row = list(map(int, input(f"Baris {i+1}: ").split()))
            if len(row) != n:
                raise ValueError("Baris harus berisi {} angka".format(n))
            key_rows.append(row)
        K = np.array(key_rows, dtype=int) % MOD
        print("Hasil enkripsi:", hill_encrypt(plaintext, K))

    elif pilih == "2":
        ciphertext = input("Masukkan ciphertext (A-Z): ").strip()
        n = int(input("Ordo matriks kunci (misal 2 untuk 2x2): ").strip())
        print("Masukkan elemen matriks kunci (baris per baris; spasi pemisah):")
        key_rows = []
        for i in range(n):
            row = list(map(int, input(f"Baris {i+1}: ").split()))
            if len(row) != n:
                raise ValueError("Baris harus berisi {} angka".format(n))
            key_rows.append(row)
        K = np.array(key_rows, dtype=int) % MOD
        print("Hasil dekripsi:", hill_decrypt(ciphertext, K))

    elif pilih == "3":
        plaintext = input("Masukkan plaintext (A-Z): ").strip()
        ciphertext = input("Masukkan ciphertext (A-Z): ").strip()
        n = int(input("Ordo matriks kunci (misal 2 untuk 2x2): ").strip())
        try:
            K_found = find_key(plaintext, ciphertext, n)
            print("Kunci ditemukan (mod 26):")
            print(K_found)
        except Exception as e:
            print("Gagal menemukan kunci:", e)

    else:
        print("Pilihan tidak valid.")